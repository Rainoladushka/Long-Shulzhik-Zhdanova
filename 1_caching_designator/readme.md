*Подробное описание требований
1.	Декоратор кэширует результат функции. Декоратор кэширует результат ранее выполненной функции, чтобы при повторном вызове этой функции с теми же параметрами мы могли вернуть результат из кэша без необходимости повторного выполнения функции.

2.	Параллелизм: декоратору необходимо поддерживать одновременное использование нескольких функций, поэтому каждая функция должна иметь собственный кеш. Это поможет функциям работать независимо и избегать конфликтов при доступе к кешу.

3.	Стратегия мемоизации — глубина кэша: декоратор должен позволять ограничивать количество результатов, хранящихся в кэше (глубину кэша). При достижении этого лимита старые результаты будут отброшены по принципу FIFO (First In, First Out).


*Объяснение кода
1.	caching_designator: функция-декоратор, позволяющая задавать глубину кэша с помощью параметра кэш_глубина.

2.	decorator: внутренняя функция декоратора создает кеш для каждой отдельной функции, использует OrderedDict для поддержания порядка элементов и удаляет самые старые элементы при достижении предела.

3.	wrapper: функция-обертка проверит кеш перед вызовом исходной функции. Если в кеше есть результат (попадание в кеш), он возвращает результат из кеша. Если нет (промах в кеше), он вычислит результат и добавит его в кеш. Когда кеш достигает предела глубины кэша, самый старый элемент удаляется.

Пример использования:

1.	Compute_square: эта функция вычисляет квадрат числа с глубиной буфера 3.
2.	Compute_sum: эта функция вычисляет сумму двух чисел с глубиной буфера 2.
При повторном вызове того же параметра результат будет взят из кэша (попадание в кэш), если он не был очищен.
